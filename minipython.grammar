// Stathoudakis Ioannis 3160164
//Vardakastanis Dimitris 3160011
//Michalas Stefanos 3160098


Package minipython;

Helpers
	digit = ['0' .. '9'];
	letter = ['a' .. 'z']|['A' .. 'Z'];

	cr = 13; 
	lf = 10;

	quote = '"';

	all = [0..127]; 
	eol = lf | cr | cr lf ;
	not_eol = [all - [cr + lf]]; 


Tokens
	tab = 9;

	plus_equal = '+=';
	plus = '+';
	plusplus = '++';

	minus_equal = '-=';	
	minus = '-';
	minusminus = '--';

	mult = '*';
	mult_equal = '*=';
	div = '/';
	div_equal = '/=';
	mod = '%';
	mod_equal = '%=';
	dmult = '**';
	dmult_equal = '**=';
		
	equal = '=';
	logic_equal = '==';

	less = '<';
	less_equal = '<=';
	greater = '>';
	greater_equal = '>=';
	not_equal = '!=';

	not = 'not';
	and = 'and';
	or = 'or';

	comma=',';
	semicolon = ';';
	semi = ':';

	l_par = '(';
	r_par = ')';
	l_br = '[';
	r_br = ']';

	if = 'if';
	elif = 'elif';
	else = 'else';
	for = 'for';
	in = 'in';
	while = 'while';
	print = 'print';
	assert = 'assert';
	return = 'return';

	def = 'def';
	
	true = 'true';
	false = 'false';
	
	blank = (' ' | lf | cr);
	line_comment = '#' not_eol* eol;

	number = digit+ | (digit+ '.' digit+);
	id = letter (letter | digit)*;
	string = '"'not_eol* '"';
	dot = '.';
	none = 'None';
	aftakia = ''';
	dipla_aftakia = '"';

Ignored Tokens
	blank, line_comment;

Productions

	goal = commands*;

	commands = {stat} statement | 
	           {func} function;

	function = {func} def l_par argument? r_par semi statement;

	argument =  {argument} id equal_value? id_equal_value*;

	equal_value = {eq_value} equal value;

	id_equal_value = {id_eq_value} comma id equal_value?;

	   
	statement =	{if} tab* if logical_eq semi statement |
				{elif} elif logical_eq semi statement |
				{else} else semi statement |
				{while} tab* while logical_eq semi statement |
				{for} tab* for [f_id]:id in [s_id]:id semi statement |
				{return} tab* return add_sub |
				{print} tab* print add_sub comma_as* |
				{assign_equals} id equal add_sub |
				{assign_add} tab* id plus_equal add_sub |
				{assign_sub} tab* id minus_equal add_sub |
				{assign_mult} tab* id mult_equal add_sub |
				{assign_div} tab* id div_equal add_sub |
				{assign_mod} tab* id mod_equal add_sub |
				{assign_power} tab* id dmult_equal add_sub |
				{array_assignment} tab* id l_br [f_expression]:add_sub r_br equal [s_expression]:add_sub |
				{assert} tab* assert add_sub comma_as? |
				{function_call} tab* function_call;


	logical_eq = {comparison} comparison |
				 {logic_eq} [f_comparison]:comparison logic_equal [s_comparison]:comparison |
				 {logic_not_eq} [f_comparison]:comparison not_equal [s_comparison]:comparison;

	comma_as = {comma_as} comma add_sub;

	dmultiplication = {expression} expression |
					  {dmultiplication} dmultiplication dmult value;

	mul_div_mod = {dmultiplication} dmultiplication |
				  {multiplication} mul_div_mod mult dmultiplication |
				  {division} mul_div_mod div dmultiplication |
				  {mode} mul_div_mod mod dmultiplication;
	
	add_sub = {mul_div_mod} mul_div_mod |
			  {addition} add_sub plus mul_div_mod |
			  {subtraction} add_sub minus mul_div_mod |
			  {prefix} prefix |
			  {postfix} postfix;

	and_or = {not} not_comp |
			 {and} [f_comparison]:logical_eq and [s_comparison]:logical_eq |
			 {or} [f_comparison]:logical_eq or [s_comparison]:logical_eq;

	not_comp = {logical_eq} logical_eq |
		  {not} not logical_eq;

	comparison = {greater} [f_expression]:add_sub greater [s_expression]:add_sub |
				 {less} [f_expression]:add_sub less [s_expression]:add_sub |
				 {less_equal} [f_expression]:add_sub less_equal [s_expression]:add_sub |
				 {greater_equal} [f_expression]:add_sub greater_equal [s_expression]:add_sub |
				 {true} true |
				 {false} false;

	expression = {add_sub} add_sub |
				 {function_call} function_call |
		         {value} value | 
				 {id_expression} id_expression |
				 {parenthesis} l_par add_sub r_par |
				 {brackets} l_br value comma_value* r_br;

	comma_value = comma value;


	id_expression = {id} id |
					{arr_brackets} id l_br add_sub r_br;

	prefix = {prefix_plus} plusplus id_expression |
			 {prefix_minus} minusminus id_expression;

	postfix = {postfix_plus} id_expression plusplus |
			 {postfix_minus} id_expression minusminus;


	function_call = {call} id l_par arglist? r_par;

	arglist = add_sub comma_as*;

	value = {number} number |
			{aftakia_string} [f]:aftakia string [s]:aftakia |
			{dipla_aftakia_string} [f]:dipla_aftakia string [s]:dipla_aftakia |
			{id_dot_fun} id dot function_call |
			{none} none;